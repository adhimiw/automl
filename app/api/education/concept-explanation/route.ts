import { NextResponse } from "next/server"
import { getServerSession } from "next-auth/next"
import { parseUserId } from "@/lib/utils/user-id"

// OpenAI API key (if available)
const OPENAI_API_KEY = process.env.OPENAI_API_KEY

// Gemini API key (if available)
const GEMINI_API_KEY = process.env.GEMINI_API_KEY

export async function GET(request: Request) {
  try {
    // Get query parameters
    const url = new URL(request.url)
    const concept = url.searchParams.get("concept")
    const difficulty = url.searchParams.get("difficulty") || "beginner"

    // Validate input
    if (!concept) {
      return NextResponse.json({ error: "Concept is required" }, { status: 400 })
    }

    // Check if we have an API key for AI services
    if (!OPENAI_API_KEY && !GEMINI_API_KEY) {
      return NextResponse.json(
        { error: "AI service is not configured. Please add an API key to the environment variables." },
        { status: 503 }
      )
    }

    // Get user session (optional)
    const session = await getServerSession()
    const userId = session?.user ? parseUserId(session.user.id) : null

    // Generate content based on the concept and difficulty
    // This is a placeholder - in a real implementation, you would call an AI service
    // For now, we'll return a structured response with basic content
    const content = generateBasicExplanation(concept, difficulty as any)

    // Log the request if user is authenticated
    if (userId) {
      // In a real implementation, you would log this to the database
      console.log(`User ${userId} requested explanation for ${concept} (${difficulty})`)
    }

    return NextResponse.json({
      id: `${concept.toLowerCase().replace(/\s+/g, "-")}-${difficulty}`,
      title: concept,
      content,
      related_concepts: getRelatedConcepts(concept),
      difficulty,
      created_at: new Date().toISOString(),
    })
  } catch (error) {
    console.error("Error generating concept explanation:", error)
    return NextResponse.json({ error: "Failed to generate concept explanation" }, { status: 500 })
  }
}

/**
 * Generate a basic explanation for a concept
 * @param concept Concept to explain
 * @param difficulty Difficulty level
 * @returns HTML content
 */
function generateBasicExplanation(
  concept: string,
  difficulty: "beginner" | "intermediate" | "advanced"
): string {
  // This is a placeholder - in a real implementation, you would call an AI service
  return `
    <h2>${concept}</h2>
    <p>This is a basic explanation for ${concept} at ${difficulty} level.</p>
    
    <h3>Key Points</h3>
    <ul>
      <li>First key point about ${concept}</li>
      <li>Second key point about ${concept}</li>
      <li>Third key point about ${concept}</li>
    </ul>
    
    <h3>Applications</h3>
    <p>This section describes how ${concept} is applied in data science and machine learning.</p>
    
    <h3>Further Reading</h3>
    <p>This section provides resources for learning more about ${concept}.</p>
    
    <div class="note">
      <p><strong>Note:</strong> This is a placeholder explanation. In a production environment, this would be generated by an AI service.</p>
    </div>
  `
}

/**
 * Get related concepts for a given concept
 * @param concept Concept to get related concepts for
 * @returns Array of related concepts
 */
function getRelatedConcepts(concept: string): string[] {
  // This is a placeholder - in a real implementation, you would have a knowledge graph
  // or use an AI service to determine related concepts
  const conceptMap: Record<string, string[]> = {
    "correlation": ["Covariance", "Regression", "Statistical Significance", "Causation"],
    "regression": ["Linear Regression", "Multiple Regression", "Polynomial Regression", "R-squared"],
    "classification": ["Logistic Regression", "Decision Trees", "Random Forests", "Support Vector Machines"],
    "clustering": ["K-Means", "Hierarchical Clustering", "DBSCAN", "Unsupervised Learning"],
    "data cleaning": ["Missing Values", "Outliers", "Data Transformation", "Feature Engineering"],
    "feature engineering": ["Feature Selection", "Dimensionality Reduction", "One-Hot Encoding", "Normalization"],
  }
  
  // Try to find an exact match
  const lowerConcept = concept.toLowerCase()
  if (conceptMap[lowerConcept]) {
    return conceptMap[lowerConcept]
  }
  
  // Try to find a partial match
  for (const [key, relatedConcepts] of Object.entries(conceptMap)) {
    if (lowerConcept.includes(key) || key.includes(lowerConcept)) {
      return relatedConcepts
    }
  }
  
  // Default related concepts
  return ["Data Science", "Machine Learning", "Statistics"]
}
